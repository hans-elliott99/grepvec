---
title: "grepvec demo"
format: 
  gfm:
    toc: true
---

`r Sys.time()`  


```{r}
# compiled on:
Sys.info()[c("sysname", "release", "version", "machine")]
```


```{r}
# make sure you installed in some way
library(grepvec)
library(microbenchmark)
set.seed(1614)

#
# create some data
#
txt <- tryCatch(
    readLines("../inst/extdata/shakespeare.txt"),
    warning = \(e) readLines("./inst/extdata/shakespeare.txt")
)
# rm document info
txt <- txt[min(which(txt == "1609")) : max(which(txt == "THE END"))]
# so we have pure Shakespeare
writeLines(c(head(txt, 15), "....", tail(txt, 5)))

#
# get some random words from the txt to use as patterns
#
gen_word_list <- function(lines, n = 10) {
    li <- as.integer(runif(n, 1, length(lines)))
    words <- paste(lines[li], collapse = " ")
    words <- unique(strsplit(words, " ")[[1]])
    words <- words[words != ""]
    words <- words[as.integer(runif(n, 1, length(words)))]
    words <- gsub("\\[|\\]|\\(|\\)", "", words)
    return(words)
}

```


## Examples


```{r}
grep("gr(a|e)y", c("grey", "gray"))
grepvec("gr(a|e)y", c("grey", "gray"))

grepvec(c("^a", "\\d"), c("1", "apple"))
lapply(c("^a", "\\d"), \(p) grep(p, c("1", "apple")))

grepvec(c("one", "possib", "many"),
        c("Some text which might possibly contain one of many keywords",
          "Another string without many words",
          "A third impossibly boring string",
          "Done"))

grepvec(letters[1:4], c("AbC", 123), ignore_case = TRUE, value = TRUE)

grepvec("^regex$", "regex")

grepvec("^fixed$", "fixed", fixed = TRUE)

```


```{r}
words <- gen_word_list(txt, n = 2000)

t0 = Sys.time()
m <- grepvec(words, txt[1:500], match = "all")
difftime(Sys.time(), t0)

# base R version
t0 = Sys.time()
m2 <- lapply(words, grep, x = txt[1:500])
difftime(Sys.time(), t0)

```

Be careful when unlisting the results, because if no match was found a 0 length vector is returned.

```{r}
res <- grepvec(words[1:100], tail(txt, 500), match = "first", value = TRUE)
head(res)

length(res)
length(unlist(res))

# helper function for flattening a list of vectors with length 0 or 1
flatten <- function(x, keepdim = TRUE) {
    if (keepdim) {
        x <- lapply(x, \(vec) if (length(vec) == 0) NA else vec[1L])
    }
    return(unlist(x))
}

length(flatten(res))

```


```{r}
pat <- gen_word_list(txt, 2000) # your vector of patterns
d <- data.frame(txt_col = txt[1001:2000], match = FALSE)

# example - get rows that match any pattern
d[unique(unlist(grepvec(pat, d$txt_col, match = "first"))), "match"] <- TRUE
head(subset(d, match == TRUE))
head(subset(d, match == FALSE))

# example - create columns based on matches
keywords <- gen_word_list(d$txt_col, 3)
cat("searching for patterns:", paste0(keywords, collapse = ", "), "\n")

d[, keywords] <- 0
(ixs <- unlist(grepvec(keywords, d$txt_col, match = "first")))

for (i in seq_along(keywords))
    d[ixs[i], keywords[i]] <- 1
## see some results
d[c(1:2, unlist(ixs)), ]

# example - getting the last match is as quick and easy as getting the first
grepvec(pat[1:2], txt, match = "first")
grepvec(pat[1:2], rev(txt), match = "first")

# example - keep dimensions to convert to a data.frame
x <- do.call(cbind.data.frame,
             grepvec(letters, txt, keepdim = TRUE, names = TRUE))
## number of occurrences in all of shakespeare
nocc <- apply(x, MARGIN = 2, FUN = \(y) sum(!is.na(y)))
sort(nocc, decreasing = TRUE)

# capital letters?
x <- do.call(cbind.data.frame,
             grepvec(LETTERS, txt, keepdim = TRUE, names = TRUE))
## number of occurrences in all of shakespeare
nocc <- apply(x, MARGIN = 2, FUN = \(y) sum(!is.na(y)))
sort(nocc, decreasing = TRUE)

# example - if you are a data.table user, functions as.data.table and setDT make
# it easy to convert a list of equal length vectors into a table 
if (require("data.table", quietly = TRUE))
    print(data.table::setDT(grepvec(c("a", "z"), txt,
                                    keepdim = TRUE, names = TRUE, value = TRUE)))
```


Invalid regex patterns:  

```{r}
# what if we use an invalid regex pattern?
grepvec(c("[bad", "(regex"), "those are bad regex patterns")

# grep is similair but throws a warning and errors out
tryCatch(
    grep("[bad", "those are bad regex patterns"),
    error = \(e) { cat("grep error message:\n"); conditionMessage(e) }
)
```


## Speed

```{r big-hay-vec}
# test grepvec on some bigger vectors
hay <- c(txt, txt)
ndl <- words
cat("N Hay =", format(length(hay), big.mark = ","),
    "| N Needle =", format(length(ndl), big.mark = ","), "\n")

t0 <- Sys.time()
suppressWarnings({
    x <- grepvec(ndl, hay, fixed = FALSE, match = "all")
})
difftime(Sys.time(), t0)

#
# returning only the first match is much faster
#
t0 <- Sys.time()
suppressWarnings({
    x <- grepvec(ndl, hay, fixed = FALSE, match = "first")
})
difftime(Sys.time(), t0)

#
# fixed searches are much much faster
# since regexes don't need be compiled or executed
#
t0 <- Sys.time()
suppressWarnings({
    x <- grepvec(ndl, hay, fixed = TRUE, match = "all")
})
difftime(Sys.time(), t0)


t0 <- Sys.time()
suppressWarnings({
    x <- grepvec(ndl, hay, fixed = TRUE, match = "first")
})
difftime(Sys.time(), t0)


```



## Compare grepvec with native R solutions

Suggestions wanted.

```{r base-r-cmp}
loop_grep <- function(needles, haystacks) {
    x <- vector(mode = "list", length = length(haystacks))
    for (i in seq_along(needles)) {
        x[[i]] <- grep(needles[i], haystacks)
    }
    x
}

lapply_grep <- function(needles, haystacks) {
    lapply(needles, grep, x = haystacks)
}

lapply_grep_lambda <- function(needles, haystacks) {
    lapply(needles, \(p) grep(p, haystacks))
}

# verify same results
shortndls <- words[1:100] 
shorttxt <- txt[1:10000]
x_loop <- loop_grep(shortndls, shorttxt)
x_lapply <- lapply_grep(shortndls, shorttxt)
x_grepvec <- grepvec(shortndls, shorttxt)
all(unlist(x_loop) == unlist(x_lapply))

# grepvec returns empty vec if no results, others return NULL. make equal
# x_grepvec <- lapply(x_grepvec, \(vec) if (length(vec) == 0) NULL else vec)
all(unlist(x_lapply) == unlist(x_grepvec))

microbenchmark(loop_grep(shortndls, shorttxt),
               lapply_grep(shortndls, shorttxt),
               lapply_grep_lambda(shortndls, shorttxt),
               grepvec(shortndls, shorttxt, match = "all"),
               times = 10)

```



Some comparisons with `base::grep`:  

`grep` is typically faster when searching for a single pattern in a single string, which makes sense considering `grepvec` has some extra overhead. The difference in performance is variable and depends on the regular expression.    

`grepvec` may become slightly faster when comparing a pattern with a bunch of strings (see the last example), but this can vary quite a bit based on the regular expression.  

`grepvec` will be most useful when searching for a vector of patterns in a vector of strings. As demonstrated above, native R solutions aren't quite as fast.  


```{r}
microbenchmark(
    grep("^[[:alnum:]._-]+@[[:alnum:].-]+$", "some-email@grep.com"),
    grepvec("^[[:alnum:]._-]+@[[:alnum:].-]+$", "some-email@grep.com")
)

microbenchmark(
    grep("([^ @]+)@([^ @]+)", "name@server.com"),
    grepvec("([^ @]+)@([^ @]+)", "name@server.com")
)

microbenchmark(
    grep("([0-9][0-9]?)/([0-9][0-9]?)/([0-9][0-9]([0-9][0-9])?)", c("01/01/1996", "2001-01-1")),
    grepvec("([0-9][0-9]?)/([0-9][0-9]?)/([0-9][0-9]([0-9][0-9])?)", c("01/01/1996", "2001-01-1"))
)

p <- gen_word_list(txt, n = 1)
microbenchmark(
    grep(p, txt),
    grepvec(p, txt)
)

cat("regex:", p, "\n")
```



## Encodings

In R, characters can be represented using many different encodings, often dependent on the user's locale and operating system.  
In the example below,  `pat = "première"` has encoding UTF8 (because that's the default in my locale) but the string stored in `lat1` has a Latin-1 encoding.  

```{r}
Sys.getlocale()

# load some text with a latin-1 encoding
lat1 <- readLines("https://raw.githubusercontent.com/stain/encoding-test-files/master/latin1.txt",
                n = 1)
cat(paste("Text:", lat1, "\nEncoding:", Encoding(lat1), "\n"))
Encoding(lat1) <- "latin1"
cat(paste("Text:", lat1, "\nSet Encoding:", Encoding(lat1), "\n"))

pat <- "première"
cat("Pattern:", pat, "\nEncoding:", Encoding(pat), "\n")
grepvec(pat, lat1)
grep(pat, lat1)


```

As you can see above, grep was able to recognize that the pattern is in the string, but grepvec was not.  
This is because grep is doing some conversion under the hood and grepvec is not.  

Instead of assuming how you want your text to be translated, grepvec assumes that your inputs are already encoded in the way you want them to be. So you can manipulate the results to your liking by converting the encoding of text at the R level:  

```{r}
Encoding(pat)
grepvec(pat, iconv(lat1, to = "UTF8"))

Encoding(lat1)
grepvec(iconv(pat, to = "latin1"), lat1)

grepvec(iconv(pat, to = "UTF8"), iconv(lat1, to = "UTF8"), fixed = TRUE)
```


You can see your 

```{r}
grep("premi.re", lat1)
grepvec("premi.re", lat1)

```

But if we indicate that the "any character could be there" extends for 2 characters, we do find a match (although this wouldn't be recommended practice)...

```{r}
grepvec("premi..re", lat1)
grep("premi..re", lat1)
```

Because, when `lat1` is translated from latin1 to UTF8, the accented 'e' now takes up 2 bytes instead of just 1. 

```{r}
(lat1 <- substr(lat1, 1, 8))
(l1_u <- iconv(lat1, "latin1", "UTF8"))
p <- "premi.re"
setNames(list(
    charToRaw(lat1),
    charToRaw(l1_u),
    charToRaw(p)
), c(paste(lat1, "-", Encoding(lat1)),
     paste(l1_u, "-", Encoding(l1_u)),
     paste(p, "-", Encoding(p))))

```

This can also cause issues when trying for a case-insensitive match.

```{r}
(p <- rawToChar(as.raw(200)))
Encoding(p) <- "latin1"
p
grep(p, lat1, ignore.case = TRUE)
grepvec(p, lat1, ignore_case = TRUE)
grepvec(iconv(p, to = "UTF8"), iconv(lat1, to = "UTF8"), ignore_case = TRUE)
## toupper causes conversion to utf8
grepvec(toupper(p), toupper(lat1))

pu <- iconv(p, "latin1", "utf8")
charToRaw(p)
charToRaw(pu)
charToRaw(toupper(lat1))

```

Solutions? Standardize the encoding of your strings first, if possible.

```{r}
l1u <- toupper(lat1)
Encoding(l1u)
grepvec("È", l1u, fixed = TRUE)
grep("È", l1u, fixed = TRUE)

if (require("stringi", quietly = TRUE)) {
    # the stringi package may help
    (p_clean <- stringi::stri_trans_general(p, "Latin-ASCII"))
    (l1_clean <- stringi::stri_trans_general(lat1, "Latin-ASCII"))
    grepvec(p_clean, l1_clean, ignore_case = TRUE)
}


# but this is still not ideal
(l1_clean <- iconv(lat1, "latin1", "UTF8"))
grepvec(iconv("È", "", "UTF8"), l1_clean, ignore_case = TRUE)
grep("È", l1_clean, ignore.case = TRUE)

```

